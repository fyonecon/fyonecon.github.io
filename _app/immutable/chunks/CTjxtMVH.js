import{q as W,E as J,aW as X,aX as G,aj as K,ac as Y,i as Z,l as g,u as H,aP as L,aV as P,ai as Q,aY as I,h as U,ad as tt}from"./DDM-VYuv.js";import{B as et}from"./D0uX6Wg0.js";import{m as nt,i as rt,a as E,d as st,e as ot,M as w,t as ct,g as ut,w as q,I as $,h as at,j as it}from"./rbXDOns6.js";function Et(t,r,...e){var o=new et(t);W(()=>{const i=r()??null;o.ensure(i,i&&(c=>i(c,...e)))},J)}function Ct(t){const r=Symbol();return{key:r,consume(){return G(r)||t},provide(e){return X(r,e)}}}function ft(t){return new Proxy({},{get(r,e){return e==="style"?o=>t({style:o}).style:t}})}var wt=()=>t=>Array.from(new Set(t));const D={className:"class",defaultChecked:"checked",defaultValue:"value",htmlFor:"for",onBlur:"onfocusout",onChange:"oninput",onFocus:"onfocusin",onDoubleClick:"ondblclick"};function O(t){let r="";for(let e in t){const o=t[e];o!=null&&(e.startsWith("--")||(e=e.replace(/[A-Z]/g,i=>`-${i.toLowerCase()}`)),r+=`${e}:${o};`)}return r}const lt=new Set("viewBox,className,preserveAspectRatio,fillRule,clipPath,clipRule,strokeWidth,strokeLinecap,strokeLinejoin,strokeDasharray,strokeDashoffset,strokeMiterlimit".split(","));function gt(t){return t in D?D[t]:lt.has(t)?t:t.toLowerCase()}function dt(t,r){return t==="style"&&typeof r=="object"?O(r):r}const Nt=ft(t=>{const r={};for(const e in t)r[gt(e)]=dt(e,t[e]);return r}),pt=/((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g,mt=t=>{const r={};let e;for(;e=pt.exec(t);)r[e[1]]=e[2];return r};function Rt(...t){const r=[];for(const o of t)o&&"class"in o&&o.class!=null&&r.push(o.class);const e=nt(...t);return r.length>0&&(e.class=r.length===1?r[0]:r),"style"in e&&(typeof e.style=="string"&&(e.style=mt(e.style)),e.style=O(e.style)),e}function M(t){const r=t().defaultValue??t().value,e=t().isEqual??Object.is;let o=K(Y(r));const i=P(()=>t().value!==void 0);let c={current:Z(()=>g(o))},p={current:void 0};H(()=>{const a=g(i)?t().value:g(o);c={current:a},p={current:a}});const v=a=>{const d=E(a)?a(c.current):a,h=p.current;t().debug&&console.log(`[bindable > ${t().debug}] setValue`,{next:d,prev:h}),g(i)||Q(o,d,!0),e(d,h)||t().onChange?.(d,h)};function m(){return g(i)?t().value:g(o)}return{initial:r,ref:c,get:m,set(a){(t().sync?L:rt)(()=>v(a))},invoke(a,d){t().onChange?.(a,d)},hash(a){return t().hash?.(a)??String(a)}}}M.cleanup=t=>{I(()=>t())};M.ref=t=>{let r=t;return{get:()=>r,set:e=>{r=e}}};function ht(t){const r={current:t};return{get(e){return r.current[e]},set(e,o){r.current[e]=o}}}const j=t=>typeof t=="function"?t():t,yt=(t,r)=>{let e=[],o=!0;U(()=>{if(o){e=t.map(c=>j(c)),o=!1;return}let i=!1;for(let c=0;c<t.length;c++)if(!st(e[c],j(t[c]))){i=!0;break}i&&(e=t.map(c=>j(c)),r())})};function z(t){return E(t)?t():t}function kt(t,r){const e=P(()=>{const{id:n,ids:s,getRootNode:f}=z(r);return at({id:n,ids:s,getRootNode:f})}),o=(...n)=>{t.debug&&console.log(...n)},i=P(()=>t.props?.({props:it(z(r)),scope:g(e)})??z(r)),c=St(()=>g(i)),p=t.context?.({prop:c,bindable:M,get scope(){return g(e)},flush:B,getContext(){return v},getComputed(){return k},getRefs(){return R},getEvent(){return N()}}),v={get(n){return p?.[n].get()},set(n,s){p?.[n].set(s)},initial(n){return p?.[n].initial},hash(n){const s=p?.[n].get();return p?.[n].hash(s)}};let m=new Map,a={current:null},d={current:null},h={current:{type:""}};const N=()=>({...h.current,current(){return h.current},previous(){return d.current}}),V=()=>({...S,hasTag(n){const s=S.get();return!!t.states[s]?.tags?.includes(n)},matches(...n){const s=S.get();return n.includes(s)}}),R=ht(t.refs?.({prop:c,context:v})??{}),y=()=>({state:V(),context:v,event:N(),prop:c,send:T,action:b,guard:_,track:yt,refs:R,computed:k,flush:B,scope:g(e),choose:F}),b=n=>{const s=E(n)?n(y()):n;if(!s)return;const f=s.map(u=>{const l=t.implementations?.actions?.[u];return l||q(`[zag-js] No implementation found for action "${JSON.stringify(u)}"`),l});for(const u of f)u?.(y())},_=n=>E(n)?n(y()):t.implementations?.guards?.[n](y()),A=n=>{const s=E(n)?n(y()):n;if(!s)return;const f=s.map(l=>{const x=t.implementations?.effects?.[l];return x||q(`[zag-js] No implementation found for effect "${JSON.stringify(l)}"`),x}),u=[];for(const l of f){const x=l?.(y());x&&u.push(x)}return()=>u.forEach(l=>l?.())},F=n=>ct(n).find(s=>{let f=!s.guard;return ut(s.guard)?f=!!_(s.guard):E(s.guard)&&(f=s.guard(y())),f}),k=n=>{ot(t.computed,()=>"[zag-js] No computed object found on machine");const s=t.computed[n];return s({context:v,event:N(),prop:c,refs:R,scope:g(e),computed:k})},S=M(()=>({defaultValue:t.initialState({prop:c}),onChange(n,s){s&&(m.get(s)?.(),m.delete(s)),s&&b(t.states[s]?.exit),b(a.current?.actions);const f=A(t.states[n]?.effects);if(f&&m.set(n,f),s===$){b(t.entry);const u=A(t.effects);u&&m.set($,u)}b(t.states[n]?.entry)}}));let C=w.NotStarted;tt(()=>{const n=C===w.Started;C=w.Started,o(n?"rehydrating...":"initializing..."),S.invoke(S.initial,$)}),I(()=>{o("unmounting..."),C=w.Stopped,m.forEach(n=>n?.()),m=new Map,a.current=null,b(t.exit)});const T=n=>{if(C!==w.Started)return;d.current=h.current,h.current=n;let s=S.get();const f=t.states[s].on?.[n.type]??t.on?.[n.type],u=F(f);if(!u)return;a.current=u;const l=u.target??s;o("transition",n.type,u.target||s,`(${u.actions})`);const x=l!==s;x?S.set(l):u.reenter&&!x?S.invoke(s,s):b(u.actions)};return t.watch?.(y()),{get state(){return V()},send:T,context:v,prop:c,get scope(){return g(e)},refs:R,computed:k,get event(){return N()},getStatus:()=>C}}function St(t){return function(e){return t()[e]}}function B(t){L(()=>{queueMicrotask(()=>t())})}export{wt as a,Ct as c,Rt as m,Nt as n,Et as s,kt as u};
