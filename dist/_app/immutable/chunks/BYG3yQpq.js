import{a_ as J,a$ as W,ad as G,a0 as K,a4 as X,x as l,ax as Z,aI as _,aF as T,ae as H,b0 as O,aa as Q,ab as U}from"./CRCNoOQn.js";import{m as Y,i as tt,a as C,b as et,e as nt,M as E,t as rt,d as st,g as q,I as M,h as ot,j as ct}from"./CffhqPQt.js";function xt(t){const r=Symbol();return{key:r,consume(){return W(r)||t},provide(e){return J(r,e)}}}function ut(t){return new Proxy({},{get(r,e){return e==="style"?o=>t({style:o}).style:t}})}var St=()=>t=>Array.from(new Set(t));const I={className:"class",defaultChecked:"checked",defaultValue:"value",htmlFor:"for",onBlur:"onfocusout",onChange:"oninput",onFocus:"onfocusin",onDoubleClick:"ondblclick"};function B(t){let r="";for(let e in t){const o=t[e];o!=null&&(e.startsWith("--")||(e=e.replace(/[A-Z]/g,g=>`-${g.toLowerCase()}`)),r+=`${e}:${o};`)}return r}const at=new Set("viewBox,className,preserveAspectRatio,fillRule,clipPath,clipRule,strokeWidth,strokeLinecap,strokeLinejoin,strokeDasharray,strokeDashoffset,strokeMiterlimit".split(","));function it(t){return t in I?I[t]:at.has(t)?t:t.toLowerCase()}function ft(t,r){return t==="style"&&typeof r=="object"?B(r):r}const bt=ut(t=>{const r={};for(const e in t)r[it(e)]=ft(e,t[e]);return r}),lt=/((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g,gt=t=>{const r={};let e;for(;e=lt.exec(t);)r[e[1]]=e[2];return r};function vt(...t){const r=[];for(const o of t)o&&"class"in o&&o.class!=null&&r.push(o.class);const e=Y(...t);return r.length>0&&(e.class=r.length===1?r[0]:r),"style"in e&&(typeof e.style=="string"&&(e.style=gt(e.style)),e.style=B(e.style)),e}function $(t){const r=t().defaultValue??t().value,e=t().isEqual??Object.is;let o=G(K(r));const g=_(()=>t().value!==void 0);let c={current:X(()=>l(o))},p={current:void 0};Z(()=>{const a=l(g)?t().value:l(o);c={current:a},p={current:a}});const b=a=>{const d=C(a)?a(c.current):a,m=p.current;t().debug&&console.log(`[bindable > ${t().debug}] setValue`,{next:d,prev:m}),l(g)||H(o,d,!0),e(d,m)||t().onChange?.(d,m)};function y(){return l(g)?t().value:l(o)}return{initial:r,ref:c,get:y,set(a){(t().sync?T:tt)(()=>b(a))},invoke(a,d){t().onChange?.(a,d)},hash(a){return t().hash?.(a)??String(a)}}}$.cleanup=t=>{O(()=>t())};$.ref=t=>{let r=t;return{get:()=>r,set:e=>{r=e}}};function dt(t){const r={current:t};return{get(e){return r.current[e]},set(e,o){r.current[e]=o}}}const j=t=>typeof t=="function"?t():t,pt=(t,r)=>{let e=[],o=!0;Q(()=>{if(o){e=t.map(c=>j(c)),o=!1;return}let g=!1;for(let c=0;c<t.length;c++)if(!et(e[c],j(t[c]))){g=!0;break}g&&(e=t.map(c=>j(c)),r())})};function z(t){return C(t)?t():t}function Ct(t,r){const e=_(()=>{const{id:n,ids:s,getRootNode:i}=z(r);return ot({id:n,ids:s,getRootNode:i})}),o=(...n)=>{t.debug&&console.log(...n)},g=_(()=>t.props?.({props:ct(z(r)),scope:l(e)})??z(r)),c=yt(()=>l(g)),p=t.context?.({prop:c,bindable:$,get scope(){return l(e)},flush:L,getContext(){return b},getComputed(){return k},getRefs(){return R},getEvent(){return N()}}),b={get(n){return p?.[n].get()},set(n,s){p?.[n].set(s)},initial(n){return p?.[n].initial},hash(n){const s=p?.[n].get();return p?.[n].hash(s)}};let y=new Map,a={current:null},d={current:null},m={current:{type:""}};const N=()=>({...m.current,current(){return m.current},previous(){return d.current}}),V=()=>({...x,hasTag(n){const s=x.get();return!!t.states[s]?.tags?.includes(n)},matches(...n){const s=x.get();return n.includes(s)}}),R=dt(t.refs?.({prop:c,context:b})??{}),h=()=>({state:V(),context:b,event:N(),prop:c,send:D,action:v,guard:F,track:pt,refs:R,computed:k,flush:L,scope:l(e),choose:A}),v=n=>{const s=C(n)?n(h()):n;if(!s)return;const i=s.map(u=>{const f=t.implementations?.actions?.[u];return f||q(`[zag-js] No implementation found for action "${JSON.stringify(u)}"`),f});for(const u of i)u?.(h())},F=n=>C(n)?n(h()):t.implementations?.guards?.[n](h()),P=n=>{const s=C(n)?n(h()):n;if(!s)return;const i=s.map(f=>{const S=t.implementations?.effects?.[f];return S||q(`[zag-js] No implementation found for effect "${JSON.stringify(f)}"`),S}),u=[];for(const f of i){const S=f?.(h());S&&u.push(S)}return()=>u.forEach(f=>f?.())},A=n=>rt(n).find(s=>{let i=!s.guard;return st(s.guard)?i=!!F(s.guard):C(s.guard)&&(i=s.guard(h())),i}),k=n=>{nt(t.computed,()=>"[zag-js] No computed object found on machine");const s=t.computed[n];return s({context:b,event:N(),prop:c,refs:R,scope:l(e),computed:k})},x=$(()=>({defaultValue:t.initialState({prop:c}),onChange(n,s){s&&(y.get(s)?.(),y.delete(s)),s&&v(t.states[s]?.exit),v(a.current?.actions);const i=P(t.states[n]?.effects);if(i&&y.set(n,i),s===M){v(t.entry);const u=P(t.effects);u&&y.set(M,u)}v(t.states[n]?.entry)}}));let w=E.NotStarted;U(()=>{const n=w===E.Started;w=E.Started,o(n?"rehydrating...":"initializing..."),x.invoke(x.initial,M)}),O(()=>{o("unmounting..."),w=E.Stopped,y.forEach(n=>n?.()),y=new Map,a.current=null,v(t.exit)});const D=n=>{if(w!==E.Started)return;d.current=m.current,m.current=n;let s=x.get();const i=t.states[s].on?.[n.type]??t.on?.[n.type],u=A(i);if(!u)return;a.current=u;const f=u.target??s;o("transition",n.type,u.target||s,`(${u.actions})`);const S=f!==s;S?x.set(f):u.reenter&&!S?x.invoke(s,s):v(u.actions)};return t.watch?.(h()),{get state(){return V()},send:D,context:b,prop:c,get scope(){return l(e)},refs:R,computed:k,get event(){return N()},getStatus:()=>w}}function yt(t){return function(e){return t()[e]}}function L(t){T(()=>{queueMicrotask(()=>t())})}export{St as a,xt as c,vt as m,bt as n,Ct as u};
